package src.pas.pacman.agents;


// SYSTEM IMPORTS
import java.util.*;


// JAVA PROJECT IMPORTS
import edu.bu.pas.pacman.agents.SearchAgent;
import edu.bu.pas.pacman.game.DefaultBoard;
import edu.bu.pas.pacman.interfaces.ThriftyPelletEater;
import edu.bu.pas.pacman.game.Action;
import edu.bu.pas.pacman.game.Game.GameView;
import edu.bu.pas.pacman.graph.Path;
import edu.bu.pas.pacman.graph.PelletGraph.PelletVertex;
import edu.bu.pas.pacman.utils.Coordinate;
import edu.bu.pas.pacman.utils.Pair;


public class PacmanAgent
    extends SearchAgent
    implements ThriftyPelletEater
{

    private final Random random;
    private Map<String, Float> edgeCache;
    private int ghostId = -1;
    public PacmanAgent(int myUnitId,
                       int pacmanId,
                       int ghostChaseRadius)
    {
        super(myUnitId, pacmanId, ghostChaseRadius);
        this.random = new Random();
    }

    public final Random getRandom() { return this.random; }
    @Override
    public Set<PelletVertex> getOutoingNeighbors(final PelletVertex vertex,
                                                 final GameView game)
    {
        Set<PelletVertex> neighbors = new HashSet<>();

        for(Coordinate coord : vertex.getRemainingPelletCoordinates()){
            PelletVertex neighbor = vertex.removePellet(coord);
            neighbors.add(neighbor);
        }
        return neighbors;
    }
    public void cacheEdges(PelletVertex src, GameView game){
        if(edgeCache == null){
            edgeCache = new HashMap<>();
        }
        Set<Coordinate> pellets = new HashSet<>(src.getRemainingPelletCoordinates());
        pellets.add(src.getPacmanCoordinate());
        for(Coordinate pellet1 : pellets) {
            PelletVertex pelletVertex = src.removePellet(pellet1);
            for (PelletVertex pellet2 : getOutoingNeighbors(pelletVertex, game)) {
                Coordinate pellet2Coord = pellet2.getPacmanCoordinate();
                if (!pellet1.equals(pellet2Coord)) {
                    if(!edgeCache.containsKey(pellet1 + " " + pellet2Coord) && !edgeCache.containsKey(pellet2Coord + " " + pellet1)){
                        edgeCache.put(pellet1 + " " + pellet2Coord, graphSearch(pellet1, pellet2Coord, game).getTrueCost());
                    }
                }
            }
        }
    }
    @Override
    public float getEdgeWeight(final PelletVertex src,
                               final PelletVertex dst)
    {
        String key = src.getPacmanCoordinate() + " " + dst.getPacmanCoordinate();
        String keyRev = dst.getPacmanCoordinate() + " " + src.getPacmanCoordinate();
        return edgeCache.get(key) != null ? edgeCache.get(key) : edgeCache.get(keyRev);
    }
    public Coordinate findRoot(Coordinate c, Map<Coordinate, Coordinate> parentMap){
        //System.out.println("Finding root of " + c + " with parent map " + parentMap);
        if(parentMap.get(c).equals(c)){
            return c;
        }else{
            Coordinate root = findRoot(parentMap.get(c), parentMap);
            parentMap.put(c, root);
            return root;
        }
    }
    @Override
    public float getHeuristic(final PelletVertex src,
                              final GameView game)
    {
        if(edgeCache == null){
            cacheEdges(src, game);
        }
        Set<Coordinate> pellets = new HashSet<>(src.getRemainingPelletCoordinates());
        //System.out.println(pellets);
        pellets.add(src.getPacmanCoordinate());
        //System.out.println(src.getRemainingPelletCoordinates());
        float mstCost = 0f;
        List<Pair<Pair<Coordinate, Coordinate>, Float>> edges = new LinkedList<>();
        for(Coordinate pellet1 : pellets) {
            PelletVertex pelletVertex = src.removePellet(pellet1);
            for (PelletVertex pellet2 : getOutoingNeighbors(pelletVertex, game)) {
                Coordinate pellet2Coord = pellet2.getPacmanCoordinate();
                if (!pellet1.equals(pellet2Coord)) {
                    //edges.add(new Pair<>(new Pair<>(pellet1, pellet2Coord), graphSearch(pellet1, pellet2Coord, game).getTrueCost()));
                    edges.add(new Pair<>(new Pair<>(pellet1, pellet2Coord), getEdgeWeight(pelletVertex, pellet2)));
                }
            }
        }
        edges.sort(Comparator.comparing(Pair::getSecond));
        Map<Coordinate, Coordinate> parentMap = new HashMap<>();
        for(Coordinate pellet : pellets) {
            //System.out.println(pellet);
            parentMap.put(pellet, pellet);
        }
        for(Pair<Pair<Coordinate, Coordinate>, Float> edge : edges) {
            Coordinate c1 = edge.getFirst().getFirst();
            Coordinate c2 = edge.getFirst().getSecond();
            //System.out.println(c1 + " " + c2 + " " + game.getCell(c1).getCellState() + " " + game.getCell(c2).getCellState());
            Coordinate root1 = findRoot(c1, parentMap);
            Coordinate root2 = findRoot(c2, parentMap);
            if(!root1.equals(root2)) {
                mstCost += edge.getSecond();
                parentMap.put(root1, root2);
            }
        }
        return mstCost;
    }

    @Override
    public Path<PelletVertex> findPathToEatAllPelletsTheFastest(final GameView game)
    {
        PelletVertex src = new PelletVertex(game);
        for (int ghost : game.getAllEntityIds()){
            if (ghost == getPacmanId()) {
                continue;
            }
            ghostId = ghost;
            break;
        }
        cacheEdges(src, game);
        //System.out.println("Finding path to fastest of " + src.getPacmanCoordinate());
        PriorityQueue<Path<PelletVertex>> pq = new PriorityQueue<>(Comparator.comparing(path -> path.getEstimatedPathCostToGoal() + path.getTrueCost()));
        Set<String> visited = new HashSet<>();
        Map<Coordinate, Coordinate> parentMap = new HashMap<>();
        Map<String, Float> costMap = new HashMap<>();
        pq.add(new Path<>(src, 0f, getHeuristic(src, game), null));
        costMap.put(src.getPacmanCoordinate()+" "+src.getRemainingPelletCoordinates(), 0f);
        //System.out.println(src.getPacmanCoordinate()+ "" + src.getRemainingPelletCoordinates().size());
        parentMap.put(src.getPacmanCoordinate(), null);
        while (!pq.isEmpty()) {
            Path<PelletVertex> currentPath = pq.poll();
            PelletVertex current = currentPath.getDestination();
            //System.out.println(current.getRemainingPelletCoordinates().size());
            if (current.getRemainingPelletCoordinates().isEmpty()) {
                //System.out.println("A* found a path to eat all pellets with cost " + currentPath.getTrueCost());
                //System.out.println(currentPath);
                return currentPath;
            }
            String keyCurrent = current.getPacmanCoordinate() + " " + current.getRemainingPelletCoordinates();
            visited.add(keyCurrent);
            for (PelletVertex neighbor : getOutoingNeighbors(current, game)) {
                //System.out.println(neighbor + " " + current.getPacmanCoordinate() + " " + currentPath.getTrueCost());
                //System.out.println(current.getPacmanCoordinate()+ "" + current.getRemainingPelletCoordinates().size());
                //System.out.println(costMap.get(keyCurrent));
                float tentativeCost = costMap.get(keyCurrent) + graphSearch(current.getPacmanCoordinate(), neighbor.getPacmanCoordinate(), game).getTrueCost();
                String keyNeighbor = neighbor.getPacmanCoordinate() + " " + neighbor.getRemainingPelletCoordinates();
                //System.out.println(visited + " " + neighbor.getPacmanCoordinate());
                if (!visited.contains(keyNeighbor)) {
                    costMap.put(keyNeighbor, tentativeCost);
                    parentMap.put(neighbor.getPacmanCoordinate(), current.getPacmanCoordinate());
                    pq.add(new Path<>(neighbor, graphSearch(current.getPacmanCoordinate(), neighbor.getPacmanCoordinate(), game).getTrueCost(), getHeuristic(neighbor, game), currentPath));
                    visited.add(keyNeighbor);

                }else if(tentativeCost < costMap.get(keyNeighbor)){
                    costMap.put(keyNeighbor, tentativeCost);
                    parentMap.put(neighbor.getPacmanCoordinate(), current.getPacmanCoordinate());
                    Path<PelletVertex> path = new Path<>(neighbor, graphSearch(current.getPacmanCoordinate(), neighbor.getPacmanCoordinate(), game).getTrueCost(), getHeuristic(neighbor, game), currentPath);
                    pq.remove(path);
                    pq.add(path);
                }else{
                    //System.out.println("Skipping neighbor " + neighbor + " with cost " + tentativeCost + " and heuristic " + getHeuristic(neighbor, game) + " and cost map " + costMap.get(keyNeighbor));
                }
            }
        }

        //System.out.println("No path found to eat all pellets ");
        return null;


    }

    @Override
    public Set<Coordinate> getOutgoingNeighbors(final Coordinate src,
                                                final GameView game)
    {
        Set<Coordinate> coords = new HashSet<Coordinate>();
        int currentX = src.getXCoordinate();
        int currentY = src.getYCoordinate();
        for (int dx = -1; dx <= 1; dx++) {
            for (int dy = -1; dy <= 1; dy++) {
                if (Math.abs(dx) != Math.abs(dy)) {
                    int newX = (int) currentX + dx;
                    int newY = (int) currentY + dy;
                    Coordinate newCoord = new Coordinate(newX, newY);
                    Action currAction = null;
                    try {
                        currAction = Action.inferFromCoordinates(src, new Coordinate(newX, newY));
                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }
                    if (game.isLegalPacmanMove(src, currAction) && !game.getEntity(ghostId).getCurrentCoordinate().equals(newCoord)) {
                        coords.add(new Coordinate(newX, newY));
                    }else if (game.getEntity(ghostId).getCurrentCoordinate().equals(newCoord)) {
                        System.out.println("Ghost at " + newCoord);
                    }
                }
            }
        }
        return coords;
    }

    @Override
    public Path<Coordinate> graphSearch(final Coordinate src,
                                        final Coordinate tgt,
                                        final GameView game)
    {
        if (ghostId == -1) {
            for (int ghost : game.getAllEntityIds()){
                if (ghost == getPacmanId()) {
                    continue;
                }
                ghostId = ghost;
                break;
            }
        }
        Coordinate currTarget = tgt;
        if (game.getEntity(ghostId).getCurrentCoordinate().equals(currTarget)) {
            Set<Coordinate> ghostneighhbors = getOutgoingNeighbors(game.getEntity(ghostId).getCurrentCoordinate(), game);
            for (Coordinate c : ghostneighhbors) {
                if (c.equals(src)) {
                    continue;
                }else{
                    currTarget = c;
                    break;
                }
            }
        }
        PriorityQueue<Path<Coordinate>> pq = new PriorityQueue<>(Comparator.comparing(Path<Coordinate>::getTrueCost));
        Set<Coordinate> visited = new HashSet<>();
        Map<Coordinate, Coordinate> parentMap = new HashMap<>();
        Map<Coordinate, Float> costMap = new HashMap<>();
        pq.add(new Path<Coordinate>(src));
        costMap.put(src, 0f);
        parentMap.put(src, null);
        while (!pq.isEmpty()) {
            Path<Coordinate> currentPath = pq.poll();
            Coordinate current = currentPath.getDestination();
            if (current.equals(currTarget)) {
                if (!currTarget.equals(tgt)) {
                    currentPath = new Path<Coordinate>(tgt, 1f, currentPath);
                }
                return currentPath;
            }
            System.out.println(getOutgoingNeighbors(current, game));
            for(Coordinate neighbor : getOutgoingNeighbors(current, game)){
                float tentativeCost = costMap.get(current) + 1f;
                if(!costMap.containsKey(neighbor) || tentativeCost < costMap.get(neighbor)){
                    costMap.put(neighbor, tentativeCost);
                    parentMap.put(neighbor, current);
                    pq.add(new Path<Coordinate>(neighbor, 1f, currentPath));
                }
            }
        }
        return null;
    }

    @Override
    public void makePlan(final GameView game) {
        Stack<Coordinate> stack = new Stack<>();
        Coordinate pacmanCoord = game.getEntity(getPacmanId()).getCurrentCoordinate();
        System.out.println(pacmanCoord+ " " + this.getTargetCoordinate());
        Path<Coordinate> path = graphSearch(pacmanCoord, this.getTargetCoordinate(), game);
        if (path == null) {
            System.out.println("Failed");
        }
        System.out.println(" from " + pacmanCoord + " to " + this.getTargetCoordinate());
        Path<Coordinate> currentPath = path;
        while (currentPath != null && currentPath.getParentPath() != null) {
            Coordinate currentCoord = currentPath.getDestination();
            stack.push(currentCoord);
            currentPath = currentPath.getParentPath();
        }
        this.setPlanToGetToTarget(stack);


    }

    @Override
    public Action makeMove(final GameView game)
    {
         cacheEdges(new PelletVertex(game), game);

         Action action = null;
         if(this.getTargetCoordinate() != null && getPlanToGetToTarget() == null){
             makePlan(game);
         }
         for (int ghost : game.getAllEntityIds()){
             if (ghost == getPacmanId()) {
                 continue;
             }
             ghostId = ghost;
             int distance = Math.abs(game.getEntity(getPacmanId()).getCurrentCoordinate().getXCoordinate() - game.getEntity(ghostId).getCurrentCoordinate().getXCoordinate()) +
                            Math.abs(game.getEntity(getPacmanId()).getCurrentCoordinate().getYCoordinate() - game.getEntity(ghostId).getCurrentCoordinate().getYCoordinate());
             if (distance <= getGhostChaseRadius() + 3) {
                 setPlanToGetToTarget(null);
                 if (getTargetCoordinate().equals(game.getEntity(getPacmanId()).getCurrentCoordinate())) {
                     float maxDist = -1;
                     Coordinate bestCoord = null;
                     for (Coordinate coord : getOutgoingNeighbors(game.getEntity(getPacmanId()).getCurrentCoordinate(), game)) {
                         int dist = Math.abs(coord.getXCoordinate() - game.getEntity(ghostId).getCurrentCoordinate().getXCoordinate()) +
                                 Math.abs(coord.getYCoordinate() - game.getEntity(ghostId).getCurrentCoordinate().getYCoordinate());
                         if (dist > maxDist) {
                             maxDist = dist;
                             bestCoord = coord;
                         }
                     }
                     setTargetCoordinate(bestCoord);
                 }
                 makePlan(game);
                 break;
             }
         }
         if(this.getTargetCoordinate() != null && getPlanToGetToTarget() != null){
             Coordinate next = null;
            if(getPlanToGetToTarget().peek().equals(game.getEntity(getPacmanId()).getCurrentCoordinate())){
                getPlanToGetToTarget().pop();
            }
            if(getPlanToGetToTarget().isEmpty()){
                setPlanToGetToTarget(null);
            }
            else{
                next = getPlanToGetToTarget().peek();
                try {
                    action = Action.inferFromCoordinates(game.getEntity(game.getPacmanId()).getCurrentCoordinate(), next);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }

            }
        }

        return action;
    }

    @Override
    public void afterGameEnds(final GameView game)
    {

    }
}
